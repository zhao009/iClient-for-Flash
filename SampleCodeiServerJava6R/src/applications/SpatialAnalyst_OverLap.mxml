<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   xmlns:ic="http://www.supermap.com/iclient/2010"
			   xmlns:is="http://www.supermap.com/iserverjava/2010" 
			   width="100%" height="100%"
			   creationComplete="initApp()">
	<s:layout>
		<s:BasicLayout/>
	</s:layout>
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import com.supermap.web.actions.Pan;
			import com.supermap.web.core.Feature;
			import com.supermap.web.core.Point2D;
			import com.supermap.web.core.geometry.GeoRegion;
			import com.supermap.web.core.styles.PredefinedFillStyle;
			import com.supermap.web.iServerJava6R.spatialAnalystServices.GeometryOverlayAnalystParameters;
			import com.supermap.web.iServerJava6R.spatialAnalystServices.GeometryOverlayAnalystResult;
			import com.supermap.web.iServerJava6R.spatialAnalystServices.GeometryOverlayAnalystService;
			import com.supermap.web.iServerJava6R.spatialAnalystServices.OverlayOperationType;
			
			import mx.controls.Alert;
			import mx.rpc.AsyncResponder;
			
			import utilEvent.ReadURLEvent;
			
			private var viewConfig:ViewConfig;
			[Bindable]
			private var mapUrl:String;
			[Bindable]
			private var dataSetUrl:String;
			private var sourceGeo:GeoRegion;
			private var operateGeo:GeoRegion;
			private function initApp():void
			{
				viewConfig = new ViewConfig(this);
				this.addEventListener(ReadURLEvent.READ_COMPLETE, readURLCompelte);
			} 
			
			//获取服务地址
			private function readURLCompelte(event:ReadURLEvent):void
			{
				//获取地图服务、数据集服务地址，默认 IP 为：localhost
				//用户若要更改服务地址，直接修改服务地址配置文件 mapUrlConfig.xml
				//或直接在此输入服务地址
				//格式如：restUrl = http://localhost:8090/iserver/services/map-world/rest/maps/World Map
				mapUrl = viewConfig.webUrl + ViewConfig.JingJin_MAP;
				dataSetUrl = viewConfig.webUrl + ViewConfig.SpatialAnylyat_DataSet;
				
				sourceGeo = new GeoRegion();
				sourceGeo.addPart([new Point2D(116.5,39.5), new Point2D(117,40), new Point2D(117.5,39.5)]);
				operateGeo = new GeoRegion();
				operateGeo.addPart([new Point2D(116.4,39.3), new Point2D(116.8,40), new Point2D(117.4,39.3)]);
				
				var feature1:Feature = new Feature(sourceGeo, new PredefinedFillStyle("solid", 0x99cc33));
				var feature2:Feature = new Feature(operateGeo, new PredefinedFillStyle("solid", 0x0099ff));
				feature2.autoMoveToTop = false;
				this.featureLayer.features = [feature2, feature1];
			}
			
			//清除叠加分析结果
			private function removeFeature():void
			{
				this.featureLayer.visible = true;
				this.overlayLayer.clear();
			}
			
			//平移
			private function panMap():void
			{
				this.map.action = new Pan(this.map);
			} 
			
			//执行叠加分析
			private function dataSetBuffer_clickHandler(event:MouseEvent):void
			{
				this.overlayLayer.clear();
				//定义几何对象叠加分析参数
				var geometryOverlayAnalystParameters:GeometryOverlayAnalystParameters = new GeometryOverlayAnalystParameters();
				geometryOverlayAnalystParameters.sourceGeometry = this.sourceGeo;
				geometryOverlayAnalystParameters.operateGeometry = this.operateGeo;
				geometryOverlayAnalystParameters.operation = OverlayOperationType.CLIP;
				
				//执定几何对象叠加分析
				var geoOverlayAnalyst:GeometryOverlayAnalystService = new GeometryOverlayAnalystService(this.dataSetUrl);
				geoOverlayAnalyst.processAsync(geometryOverlayAnalystParameters, new AsyncResponder(processCompleted, excuteErros, null));
			}
			
			//分析成功时调用的处理函数
			private function processCompleted(result:GeometryOverlayAnalystResult, mark:Object = null):void
			{
				if(result.resultGeometry)
				{
					var feature:Feature = new Feature();
					feature.style = new PredefinedFillStyle(PredefinedFillStyle.SYMBOL_SOLID, 0x99cc33);
					feature.geometry = result.resultGeometry;
					this.overlayLayer.addFeature(feature);
					this.featureLayer.visible = false;
				}
			}
			
			//分析失败时调用的处理函数
			private function excuteErros(object:Object, mark:Object = null):void
			{
				Alert.show("叠加分析失败",null,4,this);
			}
			
			//全幅
			private function viewEntireMap(event:MouseEvent):void
			{
				map.viewEntire();
			}
		]]>
	</fx:Script>
	
	<!--添加地图-->
	<ic:Map id="map" x="0" y="0"  height="100%" width="100%">
		<ic:TiledDynamicRESTLayer url="{this.mapUrl}" />
		<ic:FeaturesLayer id="overlayLayer"/>
		<ic:FeaturesLayer id="featureLayer"/>
	</ic:Map> 
	
	<s:controlBarLayout>
		<s:BasicLayout/>
	</s:controlBarLayout>
	<s:controlBarContent>
		<s:HGroup height="100%" verticalAlign="middle" left="10">
			<s:Label text="几何对象裁剪" fontSize="15" fontWeight="bold" height="26" top="100" verticalAlign="middle" fontFamily="宋体"/>
			<mx:VRule height="40" chromeColor="#434242"/>
			<s:Button label="叠加分析" click="dataSetBuffer_clickHandler(event)" fontSize="15" height="26" fontFamily="宋体" fontWeight="bold"/>
			<mx:VRule height="40" chromeColor="#434242"/>
			<s:Button label="复原" click="removeFeature()" fontSize="15" height="26" fontFamily="宋体" fontWeight="bold"/>
		</s:HGroup>
		<s:HGroup height="100%" verticalAlign="middle" right="10">
			<s:Button skinClass="skins.panBtnSkin"
					  click="panMap()"/>
			<s:Button id="entire" toolTip="全幅显示" 
					  skinClass="skins.viewEntireSkin" click="viewEntireMap(event)"/>
		</s:HGroup>
	</s:controlBarContent>
</s:Application>
